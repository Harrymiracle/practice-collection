一、 作用域
1. 作用域是什么？
作用域是根据名称查找变量的一套规则，用于确定何处以及如何查找变量。作用域经常是嵌套的，当一个块或是函数嵌套在另一个块或函数中时，就发生了作用域嵌套。
在当前作用域中无法找到某个变量时，引擎就会向外层嵌套作用域查找，直到找到该变量，或者是抵达最外层作用域（全局作用域）为止，无论找没有找到都会停止。
2. 词法作用域
词法作用域，即定义词法阶段的作用域，它是由你在写代码时把变量和作用域块写在哪里决定的，因此在词法分析处理代码时会保持作用域不变。
3. 作用域和闭包
函数可以记住并访问所在的词法作用域，即便函数在当前词法作用域外执行，都会产生闭包。
以上来自 我的 javascript之作用域 https://juejin.cn/editor/drafts/6845075646985535501

二、原型及原型链
1. 构造函数
函数简单的说就是重复执行的代码块。构造函数，它也是函数，所有的函数都可以使用new关键字来创建对象，这种用 new 操作符来调用的函数就叫做构造函数。
构造函数的特征：https://juejin.cn/post/6844903718295437320/#heading-3 
2. 什么是原型？
我们在创建一个函数时，都会有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。
3. 什么是原型链？
每个构造函数都有原型对象，每个构造函数实例都包含一个指向原型对象的内部指针（__proto__），如果我们让一个构造函数A的原型对象等于另一构造函数B的实例b，
结果这个构造函数的原型对象将包含一个指向另一个构造函数B的原型对象的指针，然后第三个构造函数C的原型对象等于构造函数A的实例a，这样构造函数C的原型对象
也将包含一个指向A的原型对象的指针。以此类推，就够成了原型对象等于另一个对象的实例，实则是以这个实例为中介，指向这个实例的原型对象，而这个实例的原型对象
又实质上指向另一个原型对象，以此形成一个链条，这就是原型链。

三、JavaScript中堆栈的理解
堆（heap）是堆内存的简称。栈（stack）是栈内存的简称。堆栈讲的就是内存的使用和分配，没有寄存器的事，也没有硬盘的事。堆是动态分配内存，
内存大小不一，也不会自动释放。栈是自动分配相对固定大小的内存空间，并由系统自动释放。
JavaScript的基本类型就6种:Undefined、Null、Boolean、Number、String和Symbol，它们都是直接按值存储在栈中的，每种类型的数据占用的内存空间的大小是确定的，
并由系统自动分配和自动释放。这样带来的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间。
JavaScript中其他类型的数据被称为引用类型的数据 : 如对象(Object)、数组(Array)、函数(Function)、Set(es6) Map(es6)…，它们是通过拷贝和new出来的，
这样的数据存储于堆中，而指向引用类型的数据的地址指针是存储于栈中的，当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，
然后，在通过地址指针找到堆中的所需要的数据。栈，线性结构，后进先出，便于管理。堆，一个混沌，杂乱无章，方便存储和开辟内存空间。
内容来源于 JS中的数据类型，包含ES6,set和map等等  https://www.cnblogs.com/cn-oldboy/p/13376310.html

四、事件循环、宏任务和微任务
详见 事件循环、宏任务和微任务 https://juejin.cn/post/6844904102510460936

五、防抖（debounce）与节流（throttle）的区别
防抖是限制某一行为在达到特定时间间隔后执行一次。如果特定时间间隔还没有达到又触发了该行为，就会重新计算间隔时间。实则就是等连续频繁的操作结束后，
再等待特定时间执行一次函数。
节流是限制某一行为在特定的时间内至多执行一次。如果在特定时间内重复触发，将不会像防抖一样重新计算间隔时间，也不会重复执行函数，而是在特定时间结束后执行一次。
实则是在触发函数行为的特定时间内只允许执行一次函数。

详见 防抖（debounce）与节流（throttle）的区别 https://juejin.cn/post/6844904103571783687

六、浏览器及JavaScript引擎工作原理
浏览器的主要组成部分：用户界面、呈现引擎、浏览器引擎、网络、用户界面后端、JavaScript 解释器、数据存储。

详见 浏览器及JavaScript引擎工作原理 https://juejin.cn/post/6844904104016232456



三十五、如何知道一串字符串中每个字母出现的次数？
var arrString = 'abcaddefaabc';

arrString.split('').reduce((res, cur) => {
    res[cur] ? res[cur] ++ : res[cur] = 1
    return res;
}, {})
