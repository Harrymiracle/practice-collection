<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- https://zhuanlan.zhihu.com/p/78113300
         https://zhuanlan.zhihu.com/p/42117531 -->

    <script>
        // console.log('1')
        // setTimeout(() => {
        //     console.log('2')
        // })
        // new Promise((resolve, rejects) => {
        //     console.log('3')
        //     resolve()
        // }).then(() => {
        //     console.log('4')
        // })
        // console.log(5)
    // 1 3 5 4 2 
// 分析： 整个javascript代码是一个宏任务，开始执行时，第一个console立即执行了，
// setTimeout是一个宏任务，加入一个宏任务的队列，
// promise执行new方法打印出3，它的then是一个微任务，加入一个队列，并在当轮宏任务执行完就会执行，
// 执行打印 5，当轮执行完，执行微任务打印出 4，执行下一轮宏任务打印出2。



        // setTimeout(_ => console.log(4))
        // new Promise(resolve => {
        //     resolve()
        //     console.log(1)
        // }).then(_ => {
        //     console.log(3)
        // })
        // console.log(2)
    // 1 2 3 4 



        // setTimeout(_ => console.log(4))
        // new Promise(resolve => {
        //     resolve()
        //     console.log(1)
        // }).then(_ => {
        //     console.log(3)
        //     Promise.resolve().then(_ => {
        //         console.log('before timeout')
        //     }).then(_ => {
        //         Promise.resolve().then(_ => {
        //             console.log('also before timeout')
        //         })
        //     })
        // })
        // console.log(2)
    // 1, 2, 3, before timeout, also before timeout, 4



        // console.log('第一次循环主执行栈开始')
        // setTimeout(function() {
        //     console.log('第二次循环开始，宏任务队列的第一个宏任务执行中')
        //     new Promise(function(resolve) {
        //         console.log('宏任务队列的第一个宏任务的微任务继续执行')
        //         resolve()
        //     }).then(function() {
        //         console.log('第二次循环的微任务队列的微任务执行')
        //     })
        // }, 0)
        // new Promise(function(resolve) {
        //     console.log('第一次循环主执行栈进行中...')
        //     resolve()
        // }).then(function() {
        //     console.log('第一次循环微任务，第一次循环结束')
        //     setTimeout(function() {
        //         console.log('第二次循环的宏任务队列的第二个宏任务执行')
        //     })
        // })
        // console.log('第一次循环主执行栈完成')

    // 第一次循环主执行栈开始
    // 第一次循环主执行栈进行中...
    // 第一次循环主执行栈完成
    // 第一次循环微任务，第一次循环结束
    // 第二次循环开始，宏任务队列的第一个宏任务执行中
    // 宏任务队列的第一个宏任务的微任务继续执行
    // 第二次循环的微任务队列的微任务执行
    // 第二次循环的宏任务队列的第二个宏任务执行
        


        // async function async1() {
        //     console.log(1); 
        //     const result = await async2(); 
        //     console.log(3); 
        // } 
        // async function async2() { 
        //     console.log(2); 
        // } 
        // Promise.resolve().then(() => { 
        //     console.log(4); 
        // }); 
        // setTimeout(() => { 
        //     console.log(5); 
        // }); 
        // async1(); 
        // console.log(6);
    // 1 2 6 4 3 5



        // Promise.resolve().then(()=>{
        //     console.log('Promise1')  
        //     setTimeout(()=>{
        //         console.log('setTimeout2')
        //     },0)
        // })
        // setTimeout(()=>{
        //     console.log('setTimeout1')
        //     Promise.resolve().then(()=>{
        //         console.log('Promise2')    
        //     })
        // },0)
    // Promise1 setTimeout1 Promise2 setTimeout2



        console.log(a);
        var a = 1;
        function a(){console.log(2);}
        console.log(a);
        var a = 3;
        console.log(a);
        function a(){console.log(4);}
        console.log(a)


    </script>
</body>
</html>