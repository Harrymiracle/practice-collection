<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>bind函数</title>
</head>
<body>
  <script>
 
  	//1 * 定义初始的函数* 这个函数的功能很简单，就是判断数字是否在某个范围
	var checkNumericRange = function (value) {
	    if (typeof value !== 'number'){
	    	return false;
	    }else{
	    	return value >= this.minimum && value <= this.maximum;
	    }      
	}

	var range = { minimum: 10, maximum: 20 };	// 这里的范围将会被绑定到函数中的this值去
	var boundCheckNumericRange = checkNumericRange.bind(range);// 开始绑定！
	var result = boundCheckNumericRange (12);// 使用一个数字来验证下这个函数
	document.write(result + "<br />");// 输出: true
//使用bind将一个对象绑定到某个函数中，这个函数中所使用的this就会指向绑上去的函数了.



	//2 ** 创建一个带有上面那个方法的对象，
	// 并且方法调用当前这个对象中的最大值和最小值
	var originalObject = {
	    minimum: 50,
	    maximum: 100,
	    checkNumRange: function (value) {
	        if (typeof value !== 'number'){
	        	return false;
	        }else{
	        	return value >= this.minimum && value <= this.maximum;
	        }	            
	    }
	}

	var result = originalObject.checkNumRange(10);// 检查10是否在范围内
	document.write(result + " ");// 输出: false
	var range = { minimum: 10, maximum: 20 };
	var boundObjectWithRange = originalObject.checkNumRange.bind(range);// bind技能要正在引导...
	var result = boundObjectWithRange(10);	// 看看这次的效果
	document.write(result);// 输出: true， 有效了！
	//bind传入的参数时，在新函数中作为最先使用绑定的参数，但是它并没有改变原函数参数的个数



	//3 *** 又是定义一个函数，这次是4个参数
	var displayArgs = function (val1, val2, val3, val4) {
	    document.write("<br />" + val1 + " " + val2 + " " + val3 + " " + val4);
	}
	var emptyObject = {};
	// 使用bind，产生一个新函数
	// 这个新函数的第一第二个参数已经定死了为这两个，再有参数往后排
	var displayArgs2 = displayArgs.bind(emptyObject, 12, "a");// 这里就是两个排队的参数了
	displayArgs2("b", "c");// 输出: 12 a b c 

	//另一个例子
	//首先、bind不同于call和apply只是单纯地设置this的值后传参，它还会将所有传入bind()方法中的实参（第一个参数之后的参数）与this一起绑定，我个人的理解是其后的参数也会作为绑定上下文的一部分
	var sum = function(x,y) { return x + y }; 
	var succ = sum.bind(null, 1); //让this指向null，其后的实参也会作为实参传入被绑定的函数sum
	succ(2) // => 3:  可以看到1绑定到了sum函数中的x

	//其次、bind()方法所返回的函数的length（形参数量）等于原函数的形参数量减去传入bind()方法中的实参数量（第一个参数以后的所有参数），因为传入bind中的实参都会绑定到原函数的形参
	function  func(a,b,c,d){ }; //func的length为4
	var after = func.bind(null,1,2)  //这里输入了两个实参（1，2）绑定到了func函数的a，b
	console.log(after.length) //after的length为 2

	//第三，当bind()所返回的函数用作构造函数的时候， 传入bind()的this将被忽略，实参会全部传入原函数
 	function original(x){
	  this.a=1;
	  this.b =function(){return this.a + x}
	}
	var obj={ a:10};
	var  newObj = new (original.bind(obj,2)); //传入了一个实参2
	console.log(newObj.a);  //输出 1, 说明返回的函数用作构造函数时obj(this的值)被忽略了
	console.log(newObj.b()); //输出3 ，说明传入的实参2传入了原函数original
	

  </script>
</body>
</html>